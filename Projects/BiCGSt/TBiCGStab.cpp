/* Generated by Together */

#include "TBiCGStab.h"
#include <oopcommmanager.h>


#include <BiCGInt.h>
#include <bicgdouble.h>
#include <tparmatrix.h>
#include <TParVector.h>

using namespace std;
/* Generated by Together */

TBiCGStab::TBiCGStab(int nproc) : OOPTask(nproc){}
TBiCGStab::~TBiCGStab(){}
/**
 * Implements the top level task of the BiCGSTAB.
 * Will set all correct data versions for all data involved and submit all
 * tasks which contribute to the BiCGSTAB
 */
OOPMReturnType TBiCGStab::Execute ()
{
#warning "Calling submit objects which is not implemented yet, data classes"
#warning "still need to be defined"
 	SubmitObjects();
  SetupTaskData();
	return ESuccess;	// execute the task, verifying that
}
long TBiCGStab::ExecTime ()
{
	return -1;
}
void TBiCBStab::SubmitObjects(){
	//If objects already submitted just go out.
	if(fObjectsSubmitted) return;

	/**
   * Create and submit the following objects on the current processor (#0)
   * Such variables holds IDs for all necessary data on the application
   * Data objects are still necessary
   */
 
   BiCGDouble * bidouble = new BiCGDouble[7]();
   fId_normb = bidouble[0]->Submit();
//   bidouble = new BiCGDouble();
   fId_rho_1 = bidouble[1]->Submit();
//   bidouble = new BiCGDouble();
   fId_rho_2 = bidouble[2]->Submit();
//   bidouble = new BiCGDouble();
   fId_alpha = bidouble[3]->Submit();
//   bidouble = new BiCGDouble();
   fId_beta = bidouble[4]->Submit();
//   bidouble = new BiCGDouble();
   fId_omega = bidouble[5]->Submit();
   TBiCGInt * biint = new TBiCGInt();
   fId_max_iter = biint->Submit();
//   bidouble = new BiCGDouble();
   fId_tol = bidouble[6]->Submit();
 
	/**
	 * Create and submit the following objects on all processors
	 * Before submitting all necessary versioning must be set, avoiding extra work
	 * on trivial dataversions.
	 */
	int i=0;
	int nproc = CM->NumProcessors();
  TParMatrix * parm;
  TParVector * parv;
  TPartitionRelation * partrel;
	for(i=0;i<nproc,i++){
    parm = new TParMatrix[2]();
		f_lId_A[i] = parm[0]->Submit();
//    parm = new TParMatrix();
		f_lId_M[i] = parm[1]->Submit();
    parv = new TParVector[10]();
		f_lId_x[i] = parv[0]->Submit();
//    parv = new TParVector();
		f_lId_b[i] = parv[1]->Submit();
//    parv = new TParVector();
		f_lId_p[i] = parv[2]->Submit();
//    parv = new TParVector();
		f_lId_shat[i] = parv[3]->Submit();
//    parv = new TParVector();
		f_lId_s[i] = parv[4]->Submit();
//    parv = new TParVector();
		f_lId_phat[i] = parv[5]->Submit();
//    parv = new TParVector();
		f_lId_t[i] = parv[6]->Submit();
//    parv = new TParVector();
		f_lId_v[i] = parv[7]->Submit();
//    parv = new TParVector();
		f_lId_rtilde[i] = parv[8]->Submit();
//    parv = new TParVector();
		f_lId_r[i] = parv[9]->Submit();
    partrel = new TPartitionRelation();
    f_lId_CMatrix[i] = partrel->Submit();
	}
	fObjectsSubmitted=true;

}
void TBiCGStab::SetupTaskData(){
  int i=0;
	int nproc = CM->NumProcessors();
	
	OOPDataVersion normbver;
	normbver = fDataDepend.Dep(fId_normb).ObjPtr()->Version();
	normbver.IncrementLevel(nproc);
	
	//Sets version of norm objects.
	fDataDepend.Dep(fId_normb).ObjPtr()->SetVersion(normbver, Id());
	
	//Sets version of fId_b object.
	OOPDataVersion ver;
	ver.IncrementLevel();	
	TDistNorm * normb;
	for(i=0;i<nproc;i++{
		normb = new TDistNorm(i);
		normb->AddDependentData(OOPMDataDepend(fId_normb, EWriteAccess, ver))
		normb->AddDependentData(OOPMDataDepend(f_lId_b[i], EReadAccess, OOPDataVersion()))
		normb->AddDependentData(OOPMDataDepend(fId_CMatrix, EReadAccess, OOPDataVersion()))
		normb->Submit();
	}
	
	//fId_normb->Version --> n.1
	normbver.DecreaseLevel();
	normbver.Increment();
  //Falta ainda submeter a tarefa que checa se a normb == 0
	
	/**
	 * Each processor will
		1 - Set the appropriate version for its written data
		2 - Trigger the necessary tasks for the computation itself
	
		PS:
			->Verify versions.
	 */
	TMultAdd * madd;
	OOPDataVersion rver = fDataDepend.Dep(fId_r[0]).ObjPtr()->Version();
	for(i=0;i<nproc;i++){
		madd = new TMultAdd(i);
		madd->AddDependentData(OOPMDataDepend(f_lId_r[i], EWriteAccess, rver));
		madd->AddDependentData(OOPMDataDepend(f_lId_rtilde[i], EWriteAccess, rver));
		madd->AddDependentData(OOPMDataDepend(f_lId_b[i], EReadAccess, OOPDataVersion()));
		madd->AddDependentData(OOPMDataDepend(f_lId_A[i], EReadAccess, OOPDataVersion()));
		madd->AddDependentData(OOPMDataDepend(f_lId_x[i], EVersionAccess, OOPDataVersion()));
		madd->AddDependentData(OOPMDataDepend(fId_CMatrix, EReadAccess, OOPDataVersion()));
		madd->Submit();
	}
	//fId_r->Version --> n.1
	rver.Increment();
	
	/**
	 * resid = Norm(r)/normb
	 */
	OOPDataVersion normrver;
	normrver = fDataDepend.Dep(fId_normr).ObjPtr()->Version();
	normrver.IncrementLevel(nproc);
	fDataDepend.Dep(fId_normr).ObjPtr()->SetVersion(normrver, Id());
	
	TDistNorm * normr;
	for(i=0;i<nproc;i++{
		normr = new TDistNorm(i);
		ver.SetLevelVersion(1,-1);
		normr->AddDependentData(OOPMDataDepend(fId_normr, EWriteAccess, ver))
		normr->AddDependentData(OOPMDataDepend(f_lId_r[i], EReadAccess, rver))
		normr->AddDependentData(OOPMDataDepend(fId_CMatrix, EReadAccess, OOPDataVersion()))
		normr->Submit();
	}
	//fId_normr->Version --> n.1
	normrver.DecreaseLevel();
	normrver.Increment();
	
	/**
	 * resid = normr/normb
	 */
	TUpdateResidue * updresidue = new TUpdateResidue(0);
	updresidue->AddDependentData(OOPMDataDepend(fId_resid,EWriteAccess,OOPDataVersion()));
	updresidue->AddDependentData(OOPMDataDepend(fId_normb,EReadAccess,normbver));
	updresidue->AddDependentData(OOPMDataDepend(fId_normr,EReadAccess,normrver));
	updresidue->Submit();

  /**
   * Loop execution will be started according to normb version.
   * The loop task is responsible for set all necessary versions on the before
   * submiting remaining tasks.
   */
  CreateLoop(normbver);
  
	
	
	/**
	 * Loop
		A
		M
		x
		b

		p
		phat
		s
		shat
		t
		v
		CMatrix

		rtilde
		r
	*/



	/**
	max_iter
	rho_1
	r
	rtilde
	normb
	p
	rho_2
	alpha
	omega
	beta
	v
	phat
	s
	x
	shat
	t
	resid
	 * Repetion for loop
	 */
	
	/**
	 * Add dependency to the following objects
	fId_rho_1
	fId_rho_2
	fId_alpha
	fId_beta
	fId_omega
	fId_max_iter
	fId_tol
	*/
}
/** This function declares and submits the loop found on the BiCGStab code.
@since 09-01-2004
@author Gustavo C. Longhin
 */
void TBiCGStab::CreateLoop(OOPDataVersion & normbVersion){
	TLoopFor * loopfor = new TLoopFor(0);

	OOPDataVersion auxver;

	auxver = fDataDepend.Dep(fId_max_iter).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_max_iter,EVersionAccess,auxver));

	auxver = fDataDepend.Dep(fId_rho_1).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_rho_1,EVersion,auxver));


	auxver = fDataDepend.Dep(fId_rho_2).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_rho_2,EVersion,auxver));

  auxver = fDataDepend.Dep(fId_alpha).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_alpha,EVersion,auxver));

	auxver = fDataDepend.Dep(fId_omega).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_omega,EVersion,auxver));

	auxver = fDataDepend.Dep(fId_beta).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_beta,EVersion,auxver));

	//auxver = fId_normb.Version();
  /**
   * Synchronizes the loop execution with normbVersion parameter.
   */
	loopfor->AddDependentData(OOPMDataDepend(fId_normb,EVersion,normbVersion);

	auxver = fDataDepend.Dep(fId_tol).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_tol,EVersion,auxver));

  auxver = fDataDepend.Dep(fId_normr).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_normr,EVersion,auxver));

	auxver = fDataDepend.Dep(fId_resid).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_resid,EVersion,auxver));

  for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_p[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_p[i],EVersion,auxver));
	}

  for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_A[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_A[i],EVersion,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_M[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_M[i],EVersion,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_v[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_v[i],EVersion,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_phat[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_phat[i],EVersion,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_s[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_s[i],EVersion,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_x[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_x[i],EVersion,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_shat[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_shat[i],EVersion,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_t[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_t[i],EVersion,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_rtilde[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_rtilde[i],EVersion,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_r[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_r[i],EVersion,auxver));
	}
  loopfor->Submit();
}
