/* Generated by Together */

#include "TLoopFor.h"

void TLoopFor::SubmitIf(){
 //if(rho_1==0) tol = Norm(r)/normb
 int i, nproc;
 OOPDataVersion version = fId_rho_1.Version();
 version.DecreaseLevel();
 version.Increment();

 OOPDataVersion tolVersion = fId_tol.Version();
 tolVersion.IncrementLevel();
 
 TIfConditional * ifcond = new TIfConditional(0);
 ifcond->AddDependentData(OOPMDataDepend(fId_rho_1, ERead, version));
 ifcond->AddDependentData(OOPMDataDepend(fId_tol, EWrite, tolVersion));
 ifcond->AddDependentData(OOPMDataDepend(fId_normr, ERead, tolVersion));
 ifcond->AddDependentData(OOPMDataDepend(fId_normb, ERead, tolVersion));
 ifcond->Submit();
 /**
  * fId_tol will be incremented anyway -->n+1
  */
}

OOPMReturnType TLoopFor::Execute ()
{
  /**
   * Submit the dot product between rtilde and r
   */
  SubmitDistDotProduct(f_lId_rtilde, f_lId_r);

  /**
   * Submit the if conditional.
   * fId_tol incremented.
   */
  SubmitIf();

  /**
   * Submits the second if on the loop instruction.
   */
  SumbmitSecondIf();
   
	return ESuccess;
}
void TLoopFor::SumbmitSecondIf(){
  OOPDataVersion version;
  version = fId_max_iter.Version();
  TSecondIf * sec = new TSecondIf(0);
  sec->AddDependentData(OOPMDataDepend(fId_max_iter, EVersion, version));
  sec->AddDependentData(OOPMDataDepend(fId_beta, EVersion, version));
  sec->AddDependentData(OOPMDataDepend(fId_rho_1, EVersion, version));
  sec->AddDependentData(OOPMDataDepend(fId_rho_2, EVersion, version));
  sec->AddDependentData(OOPMDataDepend(fId_alpha, EVersion, version));
  sec->AddDependentData(OOPMDataDepend(fId_omega, EVersion, version));

  //dentro de um for para todos os processadores
  int i, nproc;
  nproc = CM->NumProcessors();
  for(i=0;i<nproc;i++){
    sec->AddDependentData(OOPMDataDepend(f_lId_p[i], EVersion, version));
    sec->AddDependentData(OOPMDataDepend(f_lId_r[i], EVersion, version));
    sec->AddDependentData(OOPMDataDepend(f_lId_v[i], EVersion, version));
  }
  sec->Submit();
}
void TLoopFor::SubmitDistDotProduct(vector<OOPObjectId> & Id1, vector<OOPObjectId> &Id2)
{
  int i, nproc = CM->GetNumProc();
  TDotProduct * dotprod;
  /**
   * Setting the correct version for the rho_1 object
   */
  OOPDataVersion version = fId_rho_1.Version();
  version.IncrementeLevel(nproc);
  fId_rho_1.SetVersion(version);
  /**
   * Setting the level version for the dependency relation according to dotprod
   */
  version.SetLevelVersion(3,-1);
  for(i=0;i<nproc;i++){
    dotprod = new TDotProduct(i);
    dotprod->AddDependentData(OOPMDataDepend(fId_rho_1, EWrite, version));
    OOPDataVesion rtildeVersion = f_lId_rtilde[i].Version();
    dotprod->AddDependentData(OOPMDataDepend(f_lId_rtilde[i],ERead,rtildeVersion));
    OOPDataVesion rVersion = f_lId_r[i].Version();
    dotprod->AddDependentData(OOPMDataDepend(f_lId_r[i],ERead,rVersion));
    dotprod->Submit();
  }
}

long TLoopFor::ExecTime ()
{
	return -1;
}
void TLoopFor::SetupVersions(){
	OOPDataVersion auxver;

	auxver = fId_max_iter.Version();
	auxver.IncrementLevel(-1);
	fId_max_iter.SetVersion(auxver);


	auxver = fId_rho_1.Version();
	auxver.IncrementLevel(-1);
	fId_rho_1.SetVersion(auxver);


	auxver = fId_rho_2.Version();
	auxver.IncrementLevel(-1);
	fId_rho_2.SetVersion(auxver);

  auxver = fId_alpha.Version();
	auxver.IncrementLevel(-1);
	fId_alpha.SetVersion(auxver);

	auxver = fId_omega.Version();
	auxver.IncrementLevel(-1);
	fId_omega.SetVersion(auxver);

	auxver = fId_beta.Version();
	auxver.IncrementLevel(-1);
	fId_beta.SetVersion(auxver);

	auxver = fId_normb.Version();
	auxver.IncrementLevel(-1);
	fId_normb.SetVersion(auxver);

	auxver = fId_tol.Version();
	auxver.IncrementLevel(-1);
	fId_tol.SetVersion(auxver);

  auxver = fId_normr.Version();
	auxver.IncrementLevel(-1);
	fId_normr.SetVersion(auxver);

	auxver = fId_resid.Version();
	auxver.IncrementLevel(-1);
	fId_resid.SetVersion(auxver);

  for(i=0;i<nproc;i++){
		auxver = f_lId_p[i].Version();
  	auxver.IncrementLevel(-1);
  	f_lId_p[i].SetVersion(auxver);
	}

  for(i=0;i<nproc;i++){
		auxver = f_lId_A[i].Version();
  	auxver.IncrementLevel(-1);
  	f_lId_A[i].SetVersion(auxver);
	}

	for(i=0;i<nproc;i++){
		auxver = f_lId_M[i].Version();
  	auxver.IncrementLevel(-1);
  	fId_rho_2.SetVersion(auxver);
	}

	for(i=0;i<nproc;i++){
		auxver = f_lId_v[i].Version();
  	auxver.IncrementLevel(-1);
  	fId_rho_2.SetVersion(auxver);
	}

	for(i=0;i<nproc;i++){
		auxver = f_lId_phat[i].Version();
  	auxver.IncrementLevel(-1);
  	f_lId_phat[i].SetVersion(auxver);
	}

	for(i=0;i<nproc;i++){
		auxver = f_lId_s[i].Version();
  	auxver.IncrementLevel(-1);
  	f_lId_s[i].SetVersion(auxver);
	}

	for(i=0;i<nproc;i++){
		auxver = f_lId_x[i].Version();
  	auxver.IncrementLevel(-1);
  	f_lId_x[i].SetVersion(auxver);
	}

	for(i=0;i<nproc;i++){
		auxver = f_lId_shat[i].Version();
  	auxver.IncrementLevel(-1);
  	f_lId_shat[i].SetVersion(auxver);
	}

	for(i=0;i<nproc;i++){
		auxver = f_lId_t[i].Version();
  	auxver.IncrementLevel(-1);
  	f_lId_t[i].SetVersion(auxver);
	}

	for(i=0;i<nproc;i++){
		auxver = f_lId_rtilde[i].Version();
  	auxver.IncrementLevel(-1);
  	f_lId_rtilde[i].SetVersion(auxver);
	}

	for(i=0;i<nproc;i++){
		auxver = f_lId_r[i].Version();
  	auxver.IncrementLevel(-1);
  	f_lId_r[i].SetVersion(auxver);
	}
	
}
