/* Generated by Together */
#include "TContribution.h"
#include <stdlib.h>
class OOPStorageBuffer;
bool TContribution::operator == (const TContribution & contr)
{
	if (!(fDestinationMesh == contr.fDestinationMesh))
		return false;
	if (fFrom.size () != contr.fFrom.size ())
		return false;
	if (fLocalIndices.size () != contr.fLocalIndices.size ())
		return false;
	if (fNContributions != contr.fNContributions)
		return false;
	if (fTo.size () != contr.fTo.size ())
		return false;
	return true;
}
TContribution & TContribution::operator= (const TContribution & contr)
{
	fDestinationMesh = contr.fDestinationMesh;
	fFrom = contr.fFrom;
	fLocalIndices = contr.fLocalIndices;
	fNContributions = contr.fNContributions;
	fTo = contr.fTo;
	return *this;
}
TContribution::TContribution ()
{
	fNContributions = 0;
}
int TContribution::IsEmpty ()
{
	return fNContributions == 0;
}
vector < int >&TContribution::DestinationVector (int index)
{
	if (index < (int) fLocalIndices.size ()) {
		return fLocalIndices[index];
	}
	else {
		cout << "TContribution::DestinationVector index out of range index " << index << endl;
		return fLocalIndices[0];
	}
}
void TContribution::InitializeRandom ()
{
	fNContributions = 1+(int) (5*rand()/(RAND_MAX+1.0));//rs % 5;
	fLocalIndices.resize (fNContributions);
	fFrom.resize(fNContributions);
	fTo.resize(fNContributions);
	int ic;
	for (ic = 0; ic < fNContributions; ic++) {
		fFrom[ic] = 1+(int) (7*rand()/(RAND_MAX+1));//rand()%7;
		fTo[ic] = 1+(int) (6*rand()/(RAND_MAX+1));//rand()%6;
		fLocalIndices[ic].resize (1+(int) (20*rand()/(RAND_MAX+1)));//rand () % 10);
		int nl = fLocalIndices[ic].size ();
		int ind;
		for (ind = 0; ind < nl; ind++) {
			fLocalIndices[ic][ind] = ind + 10;
		}
	}
}
/**
 * Packs the object in on the buffer so it can be transmitted through the network.
 * The Pack function  packs the object's class_id while function Unpack() doesn't,
 * allowing the user to identify the next object to be unpacked.
 * @param buf A pointer to TSendStorage class to be packed.
 */
void TContribution::Write (TPZStream & buf, int withclassid){
	fDestinationMesh.Write(buf);
	int i,sz;
	sz = fFrom.size();
	buf.Write(&sz);
	for(i=0; i<sz; i++) buf.Write(&fFrom[i]);
	sz = fTo.size();
	buf.Write(&sz);
	for(i=0; i<sz; i++) buf.Write(&fTo[i]);
	sz = fLocalIndices.size();
	buf.Write(&sz);
	for(i=0; i<sz; i++) {
		int lsz = fLocalIndices[i].size();
		int il;
		buf.Write(&lsz);
		for(il=0; il<lsz; il++) {
			buf.Write(&fLocalIndices[i][il]);
		}
	}
	buf.Write(&fNContributions);
}
/**
 * Unpacks the object class_id
 * @param buf A pointer to TSendStorage class to be unpacked.
 */
void TContribution::Read (TPZStream & buf, void * context){
	fDestinationMesh.Read(buf);
	int i,sz;
	buf.Read(&sz);
	fFrom.resize(sz);
	for(i=0; i<sz; i++) buf.Read(&fFrom[i]);
	buf.Read(&sz);
	fTo.resize(sz);
	for(i=0; i<sz; i++) buf.Read(&fTo[i]);
	buf.Read(&sz);
	fLocalIndices.resize(sz);
	for(i=0; i<sz; i++) {
		int lsz,il;
		buf.Read(&lsz);
		fLocalIndices[i].resize(lsz);
		for(il=0; il<lsz; il++) {
			buf.Read(&fLocalIndices[i][il]);
		}
	}
	buf.Read(&fNContributions);
}
