/* Generated by Together */

#include "TPartitionRelation.h"
//#include "pzvec.h"

TPartitionRelation::TPartitionRelation() : OOPSaveable() {}
int TPartitionRelation::OutgoingContribution(int partition){
	int counter;
	int i;
	for(i=0;i<fNumPartitions;i++){
		//Ainda precisa ser implementado com a funcionalidade esperada
		if (fRelation[partition][i].NContributions()){
			counter++;
		}
	}
	return counter;
	
	
}
int TPartitionRelation::IncomingContribution(int partition){
	int i;
	int count = 0;
	for(i=0;i<fNumPartitions;i++){
		//Ainda precisa ser implementado com a funcionalidade esperada
		if (fRelation[i][partition].NContributions()){
			count ++;
		}
	}
	return count;
	
}
int TPartitionRelation::GetNPartitions(){
	return fNumPartitions;
}
long TPartitionRelation::GetClassID(){
	return fClassId;
}

TPartitionRelation * TPartitionRelation::CreateRandom(int npart){
	TPartitionRelation * part = new TPartitionRelation(npart);
	part->fRelation.resize(npart);
	int i,j;
	for(i=0;i<npart;i++)
		part->fRelation[i].resize(npart);
	
	for(i=0;i<npart;i++){
		for(j=0;j<npart;j++){
			part->fRelation[i][j].InitializeRandom();
		}
	}
	
	return part;
}

void TPartitionRelation::Print(ostream &out) {
  int i;
  for(i=0; i<fNumPartitions; i++) {
    out << "Partition " << i << " contributes to " << OutgoingContribution(i) << " partitions\n";
    out << "Partition " << i << " receives from " << IncomingContribution(i) << " partitions\n";
  }
}

void TPartitionRelation::SetMeshId(int index, OOPObjectId &meshid) {
  int ip;
  for(ip =0; ip<fNumPartitions; ip++) {
    fRelation[ip][index].SetMeshId(meshid);
  }
}
