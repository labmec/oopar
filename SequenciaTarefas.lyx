#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\language brazil
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Section*

Explicações sobre o funcionamento do OOPar
\layout Subsection*

Sequencia de eventos em torno de tarefas
\layout Standard

Quando uma tarefa é submetida ao TM, a seguinte sequencia de eventos deve
 ocorrer
\layout Subsubsection*

Submissão de tarefas
\layout Standard

Na submissão da tarefa, a sua lista de dependências deve ser encaminhada
 para o DM.
 A submissão dessas dependências é feita no método 
\emph on 
SubmitDependencyList
\emph default 
.
 O método de OOPTask encaminha esta chamada para 
\emph on 
PostAccessRequests
\emph default 
 da classe 
\emph on 
OOPAccessTagList.
 
\emph default 
Visto que os objetos não 
\emph on 
sabem
\emph default 
 o processador associados ao pedido, passamos o processador atual aos objetos
 da lista.
\layout Subsubsection*

finalizando a tarefa
\layout Standard

Na finalização da tarefa, os dados que foram modificados (acesso para escrito)
 devem ser resubmetidos ao DM.
 Em seguido os ponteiros para os dados (
\emph on 
TPZAutoPointer
\emph default 
) devem ser zerados.
 Finalmente, o DM é notificado que o número de acessos dos objetos foi modificad
o.
\layout Standard

A resubmissão dos objetos é feito no método 
\emph on 
SubmitIncrementedVersions()
\emph default 
 da classe OOPAccessTagList.
 O método correspondente da classe OOPTask é 
\emph on 
ReleaseDepObjPtr()
\emph default 
.
\layout Standard

O método chamado dentro do OOPTaskControl é 
\emph on 
UpdateVersions()
\emph default 

\begin_inset Foot
collapsed true

\layout Standard

Estranhamente, todas as operações necessárias estavem programadas neste
 método, mas estavem comentadas.
\end_inset 


\layout Section*

Funcionamento de autopointer
\layout Standard

O objeto autopointer é um objeto que 
\emph on 
administra
\emph default 
 o objeto em torno do qual foi criado.
 Isto significa que somente um objeto autopointer pode ser criado em torno
 de um objeto TPZSaveable.
 Caso contrario, no destrutor do TPZAutoPointer o destrutor do objeto sera
 chamado, independemente que este objeto é referenciado por outro autopointer.
\layout Standard

No código que existia, somente tinha metodo GetPointer que devolvia um ponteiro
 para TPZSaveable.
 Implicitamente este ponteira era convertido em TPZAutoPointer no método
 Submit da class OOPMetaData.
 Modifiquei o método Submit, trocando o argumento de objeto AutoPointer
 para uma referencia para AutoPointer.
 Isto tem como consequencia que o codigo nao compila caso tenta se passar
 um objeto TPZSaveable * para o método.
\layout Standard

O método GetPointer somente pode ser utilizado excepcionalmente.
 Foi colocado para satisfazer o objeto OOPTask.
 Utiliza o método AutoPointer sempre.
\layout Subsection*

Como depurar um autopointer
\layout Standard

A chave do autopointer esta no seu mechanismo de contagem de objetos referenciad
os.
 Quando algum erro acontecer, é normalmente devido ao destrutor do objeto
 a qual aponta.
\layout Standard

Normalmente, sabe-se qual deveria ser o contador do autopointer, porque
 sabe-se quais objetos na estrutura de dados referenciam o mesmo objeto
\emph on 
 referenciado
\emph default 
.
 Caso o contador esta errado, precisa-se procurar saber porque.
\layout Standard

Outra maneira é colocando um breakpoint na linha de codigo onde o destrutor
 do objeto referenciado é chamado.
 Olha-se o 
\emph on 
framestack
\emph default 
 do código para saber onde o destrutor do autopointer é chamado e tenta-se
 entender porque o contador estava zerado.
\layout Section*

O que significa o operador < para OOPAccessTag
\layout Standard

O accesstag esta armazenado em um multiset dentro do metadata.
 Por isso esta classe deve implementar o operador <.
 Este operador vai determinar a ordem dentro da qual os objetos sao armazenados
 dentro do 
\emph on 
container
\emph default 
.
\layout Standard

Nota que somente quando os objetos são 
\emph on 
iguais
\emph default 
 o operador < vai retornar false para ambos 
\begin_inset Formula $A<B$
\end_inset 

 e 
\begin_inset Formula $B<A$
\end_inset 

.
\layout Standard

Qual ordem queremos dar a esses objetos? O multiset contém o conjunto de
 pedidos de acess.
 O metadata vai utilizar o multiset para comparar a versão de um objeto
 com a versão que cada um dos pedidos precisa.
 Seria então lógico de ordenar os objetos por versão.
\layout Standard

Caso as versões são iguais, sabemos que um pedido de acesso a leitura tem
 prioridade de consessão sobre um pedido de acesso a escrito.
 Faria sentido colocar os objetos com acesso a leitura antes dos objetos
 de acesso a escrito.
\layout Standard

A ordem dos processores não tem importância.
\layout Standard

Finalmente pode ser utilizado a comparação do ponteiro do objeto referenciado.
\layout Subsection*

Como calcular um operador de dados em sequencia
\layout Standard

Caso tem-se um vetor (conjunto de) objetos para os quais deseja-se estabelecer
 uma comparação, existe a possibilidade de proseguir da seguinte forma:
\layout Standard

Percorrer os objetos em ordem
\layout Standard

Caso 
\begin_inset Formula $A[i]<B[i]$
\end_inset 

 return true; 
\layout Standard

Caso 
\begin_inset Formula $A[i]!=B[i]$
\end_inset 

 return false; (poderia ser 
\begin_inset Formula $B[i]>A[i]$
\end_inset 

)
\layout Standard

Adaptei a programação das classes OOPDataVersion, OOPAccessTag e OOPObjectId.
\layout Section*

Como compor uma OOPDMRequestTask
\layout Standard

Caso uma tarefa pede acesso a um dado que encontra-se em outro processador,
 um pedido de acesso deve ser encaminhado através da rede.
 Este pedido de acesso é a atribuição dos objetos do tipo 
\emph on 
OOPDMRequestTask
\emph default 
.
 Tentaremos elucidar como compor um objeto deste tipo.
 A informação contida dentro do OOPAccesTag do pedido de acesso da tarefa
 é diferente da informação contida dentro do request task.
 O request task formula um pedido de acesso para um processador.
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="8" columns="5">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

dado
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

significado para task
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

significado para request
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

fAccessMode
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

tipo de acesso (READ/WRITE)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

tipo de acesso (READ/WRITE)
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

fObjectAutoPtr
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

ponteiro para dado
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

fObjectId
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

identificador do objeto
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

identificador do objeto
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

fProcessor
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

sem uso
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

processador onde sera executado a tarefa
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

fTaskId
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

identificador da tarefa
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

sem uso
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

fVersion
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

versão requisitada pela tarefa
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

versão requisitada pelo processador
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Section*

Quando um request task deve ser encaminhado
\layout Standard

Quando uma tarefa pede acesso a um dado que esta sendo administrado por
 outro processador, pode ser que uma request task precisa ser encaminhada.
 O que interesse é quando tal pedido não precisa ser encaminhado.
\layout Standard

Caso outra tarefa já pediu anteriormente acesso ao dado pela mesma versão,
 não há necessidade de repetir o pedido.
 Antes de compor o request task, é preciso percorrer os pedido do fAccessList
 do metadata para verificar se tal pedido existe.
 Para tal, colocou-se o método HasSimilarRequests(OOPAccessTag &) na classe
 OOPAccessTagMultiSet
\layout Subsection*

Quais são os pedidos que precisam ser encaminhados quando a administração
 do dado troca de processador
\layout Standard

Como mencionado anteriormente, existe diferença entre o pedido encaminhado
 por uma tarefa e pedido encaminhado por um processador.
 A troca do OOPAccessTag de pedido de tarefa para pedido de processador
 é bastante simples.
 Como processador, coloca-se DM->GetProcID() e zera-se o fTaskId.
 Visto que várias tarefas podem querer acessar o mesmo dado com a mesma
 versão, pedidos de acesso por tarefa podem tornar-se idênticos quando transform
ados em pedidos de processador.
 Programou-se o método GetProcessorAccessRequests(int processor, std::set<OOPAcc
essTag> &requestlist) na classe OOPAccessTagMultiSet
\layout Standard

\the_end
