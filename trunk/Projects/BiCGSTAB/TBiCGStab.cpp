/* Generated by Together */

#include "TBiCGStab.h"
/* Generated by Together */
/**
 * Implements the top level task of the BiCGSTAB.
 * Will set all correct data versions for all data involved and submit all
 * tasks which contribute to the BiCGSTAB
 */
OOPMReturnType TBiCGStab::Execute ()
{
#warning "Execute not implemented"
	SubmitObjects();
	SetupTaskData();
	return ESuccess;	// execute the task, verifying that
}
long TBiCGStab::ExecTime ()
{
	return -1;
}
void SubmitObjects(){
	//If objects already submitted just go out.
	if(fObjectsSubmitted) return;

	//Create and submit the following objects on the current processor (#0)
	fId_normb
	fId_rho_1
	fId_rho_2
	fId_alpha
	fId_beta
	fId_omega
	fId_max_iter
	fId_tol

	/**
	 * Create and submit the following objects on all processors
	 * Before submitting all necessary versioning must be set, avoiding extra work
	 * on trivial dataversions.
	 */
	int i=0;
	int nproc = CM->NumProcessors();
	for(i=0;i<nproc,i++){
		fId_A[i]
		fId_M[i]
		fId_x[i]
		fId_b[i]
		fId_p[i]
		fId_shat[i]
		fId_s[i]
		fId_shat[i]
		fId_t[i]
		fId_v[i]
		fId_CMatrix[i]
		fId_rtilde[i]
		fId_r[i]
	}
	fObjectsSubmitted=true;
	
}
void SetupTaskData(){
	int i=0;
	int nproc = CM->NumProcessors();
	OOPDataVersion ver;
	
	ver = fId_normb.Version();
	ver.IncrementLevel(nproc);
	
	//Sets version of fId_normb object.
	fId_normb.SetVersion(ver);
	//Sets version of fId_b object.
		
	TDistNorm * normb;
	for(i=0;i<nproc;i++{
		normb = new TDistNorm(i);
		ver.SetVersion(1,-1);
		normb->AddDependentData(OOPMDataDepend(fId_normb, EWrite, ver))
		normb->AddDependentData(OOPMDataDepend(fId_b[i], ERead, OOPDataVersion()))
		normb->AddDependentData(OOPMDataDepend(fId_CMatrix, ERead, OOPDataVersion()))
		normb->Submit();
	}
	//fId_normb->Version --> n.1
	
	
	/**
	 * Each processor will
		1 - Set the appropriate version for its written data
		2 - Trigger the necessary tasks for the computation itself
	 */
	TMultAdd * madd;
	for(i=0;i<nproc;i++{
		madd = new TMultAdd(i);
		madd->AddDependentData(OOPMDataDepend(fId_r[i], EVersion, OOPDataVersion());
		madd->AddDependentData(OOPMDataDepend(fId_b[i], ERead, OOPDataVersion());
		madd->AddDependentData(OOPMDataDepend(fId_A[i], ERead, OOPDataVersion());
		madd->AddDependentData(OOPMDataDepend(fId_x[i], EVersion, OOPDataVersion());
		madd->AddDependentData(OOPMDataDepend(fId_CMatrix, ERead, OOPDataVersion());
		madd->Submit();
	}
	//fId_r->Version --> n.1
	
	
	fId_rho_1
	fId_rho_2
	fId_alpha
	fId_beta
	fId_omega
	fId_max_iter
	fId_tol
}
