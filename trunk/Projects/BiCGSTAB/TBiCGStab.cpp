/* Generated by Together */

#include "TBiCGStab.h"

/**
 * Implements the top level task of the BiCGSTAB.
 * Will set all correct data versions for all data involved and submit all
 * tasks which contribute to the BiCGSTAB
 */
OOPMReturnType TBiCGStab::Execute ()
{
#warning "Calling submit objects which is not implemented yet, data classes"
#warning "still need to be defined"
 	SubmitObjects();
	SetupTaskData();
	return ESuccess;	// execute the task, verifying that
}

long TBiCGStab::ExecTime ()
{
	return -1;
}

void TBiCGStab::SubmitObjects() {
	//If objects already submitted just go out.
	if(fObjectsSubmitted) return;
	
	//Create and submit the following objects on the current processor (#0)
	//Such variables holds IDs for all necessary data on the application
	//Data objects are still necessary

	/*
	 fId_normb
	 fId_rho_1
	 fId_rho_2
	 fId_alpha
	 fId_beta
	 fId_omega
	 fId_max_iter
	 fId_tol
	 */

	// Create and submit the following objects on all processors
	// Before submitting all necessary versioning must be set, avoiding extra work
	// on trivial dataversions.
	int i=0;
	int nproc = CM->NumProcessors();
	for(i=0;i<nproc,i++){
		f_lId_A[i]
		f_lId_M[i]
		f_lId_x[i]
		f_lId_b[i]
		f_lId_p[i]
		f_lId_shat[i]
		f_lId_s[i]
		f_lId_phat[i]
		f_lId_t[i]
		f_lId_v[i]
		f_lId_CMatrix[i]
		f_lId_rtilde[i]
		f_lId_r[i]
	}
	fObjectsSubmitted=true;
}

void TBiCGStab::SetupTaskData(){
	int i=0;
	int nproc = CM->NumProcessors();
	
	OOPDataVersion normbver;
	normbver = fId_normb.Version();
	normbver.IncrementLevel(nproc);
	
	//Sets version of norm objects.
	fId_normb.SetVersion(normbver);
	
	//Sets version of fId_b object.
	OOPDataVersion ver;
	ver.IncrementLevel();	
	TDistNorm * normb;
	for(i=0;i<nproc;i++) {
		normb = new TDistNorm(i);
		normb->AddDependentData(OOPMDataDepend(fId_normb, EWrite, ver))
		normb->AddDependentData(OOPMDataDepend(f_lId_b[i], ERead, OOPDataVersion()))
		normb->AddDependentData(OOPMDataDepend(fId_CMatrix, ERead, OOPDataVersion()))
		normb->Submit();
	}
	
	//fId_normb->Version --> n.1
	normbver.DecreaseLevel();
	normbver.Increment();
	
	
	// Each processor will
	// 1 - Set the appropriate version for its written data
	// 2 - Trigger the necessary tasks for the computation itself
	 
	// PS:
	// ->Verify versions.
	TMultAdd * madd;
	OOPDataVersion rver;
	rver = fId_r[0].Version();
	for(i=0;i<nproc;i++) {
		madd = new TMultAdd(i);
		madd->AddDependentData(OOPMDataDepend(f_lId_r[i], EWrite, rver));
		madd->AddDependentData(OOPMDataDepend(f_lId_rtilde[i], EWrite, rver));
		madd->AddDependentData(OOPMDataDepend(f_lId_b[i], ERead, OOPDataVersion()));
		madd->AddDependentData(OOPMDataDepend(f_lId_A[i], ERead, OOPDataVersion()));
		madd->AddDependentData(OOPMDataDepend(f_lId_x[i], EVersion, OOPDataVersion()));
		madd->AddDependentData(OOPMDataDepend(fId_CMatrix, ERead, OOPDataVersion()));
		madd->Submit();
	}
	//fId_r->Version --> n.1
	rver.Increment();
	
	// resid = Norm(r)/normb
	OOPDataVersion normrver;
	normrver = fId_normr.Version();
	normrver.IncrementLevel(nproc);
	fId_normr.SetVersion(normrver);
	
	TDistNorm * normr;
	for(i=0;i<nproc;i++) {
		normr = new TDistNorm(i);
		ver.SetVersion(1,-1);
		normr->AddDependentData(OOPMDataDepend(fId_normr, EWrite, ver))
		normr->AddDependentData(OOPMDataDepend(f_lId_r[i], ERead, rver))
		normr->AddDependentData(OOPMDataDepend(fId_CMatrix, ERead, OOPDataVersion()))
		normr->Submit();
	}
	//fId_normr->Version --> n.1
	normrver.DecreaseLevel();
	normrver.Increment();
	
	TUpdateResidue * updresidue = new TUpdateResidue(0);
	updresidue->AddDependentData(OOPMDataDepend(fId_resid,EWrite,OOPDataVersion()));
	updresidue->AddDependentData(OOPMDataDepend(fId_normb,ERead,normbver));
	updresidue->AddDependentData(OOPMDataDepend(fId_normr,ERead,normrver));
	updresidue->Submit();
	
	// Loop execution will be started according to normb version.
	// The loop task is responsible for set all necessary versions on the before
	// submiting remaining tasks.
	CreateLoop(normbver);

}

//This function declares and submits the loop found on the BiCGStab code.
void TBiCGStab::CreateLoop(OOPDataVersion & normbVersion){
	TLoopFor * loopfor = new TLoopFor(0);
	
	OOPDataVersion auxver;
	
	auxver = fId_max_iter.Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_max_iter,EVersion,auxver));
	
	auxver = fId_rho_1.Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_rho_1,EVersion,auxver));
	
	
	auxver = fId_rho_2.Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_rho_2,EVersion,auxver));
	
	auxver = fId_alpha.Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_alpha,EVersion,auxver));
	
	auxver = fId_omega.Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_omega,EVersion,auxver));
	
	auxver = fId_beta.Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_beta,EVersion,auxver));
	
	loopfor->AddDependentData(OOPMDataDepend(fId_normb,EVersion,normbVersion));
	
	auxver = fId_tol.Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_tol,EVersion,auxver));
	
	auxver = fId_normr.Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_normr,EVersion,auxver));
	
	auxver = fId_resid.Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_resid,EVersion,auxver));
	
	for(i=0;i<nproc;i++){
		auxver = f_lId_p[i].Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_p[i],EVersion,auxver));
	}
	
	for(i=0;i<nproc;i++){
		auxver = f_lId_A[i].Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_A[i],EVersion,auxver));
	}
	
	for(i=0;i<nproc;i++){
		auxver = f_lId_M[i].Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_M[i],EVersion,auxver));
	}
	
	for(i=0;i<nproc;i++){
		auxver = f_lId_v[i].Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_v[i],EVersion,auxver));
	}
	
	for(i=0;i<nproc;i++){
		auxver = f_lId_phat[i].Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_phat[i],EVersion,auxver));
	}
	
	for(i=0;i<nproc;i++){
		auxver = f_lId_s[i].Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_s[i],EVersion,auxver));
	}
	
	for(i=0;i<nproc;i++){
		auxver = f_lId_x[i].Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_x[i],EVersion,auxver));
	}
	
	for(i=0;i<nproc;i++){
		auxver = f_lId_shat[i].Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_shat[i],EVersion,auxver));
	}
	
	for(i=0;i<nproc;i++){
		auxver = f_lId_t[i].Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_t[i],EVersion,auxver));
	}
	
	for(i=0;i<nproc;i++){
		auxver = f_lId_rtilde[i].Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_rtilde[i],EVersion,auxver));
	}
	
	for(i=0;i<nproc;i++){
		auxver = f_lId_r[i].Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_r[i],EVersion,auxver));
	}
	loopfor->Submit();
}
