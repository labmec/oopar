/* Generated by Together */

#include "TBiCGStab.h"
#include <oopcommmanager.h>



#include <bicgdouble.h>
#include <tparmatrix.h>
#include <TParVector.h>
#include <TPartitionRelation.h>
#include <TMultAdd.h>
#include <TUpdateResidue.h>
#include <tbicg_one.h>
using namespace std;
/* Generated by Together */

OOPSaveable * TBiCGStab::Restore(OOPReceiveStorage * buf){
      TBiCGStab * bicg = new TBiCGStab(0);
      bicg->Unpack(buf);
      return bicg;
}

TBiCGStab::TBiCGStab(int nproc) : OOPTask(nproc){
  fObjectsSubmitted=0;
}
TBiCGStab::~TBiCGStab(){}
/**
 * Implements the top level task of the BiCGSTAB.
 * Will set all correct data versions for all data involved and submit all
 * tasks which contribute to the BiCGSTAB
 */
OOPMReturnType TBiCGStab::Execute ()
{
#warning "Calling submit objects which is not implemented yet, data classes"
#warning "still need to be defined"
 	SubmitObjects();
  SetupTaskData();
	return ESuccess;	// execute the task, verifying that
}
long TBiCGStab::ExecTime ()
{
	return -1;
}
void TBiCGStab::SubmitObjects(){
  
  //If objects already submitted just go out.
  if(fObjectsSubmitted) return;
  
  /**
   * Create and submit the following objects on the current processor (#0)
   * Such variables holds IDs for all necessary data on the application
   * Data objects are still necessary
   */
 
  BiCGDouble * bidouble = new BiCGDouble[7];
  fId_normb = DM->SubmitObject(bidouble);
  //   bidouble = new BiCGDouble();
  bidouble++;
  fId_rho_1 = DM->SubmitObject(bidouble);
  bidouble++;
  //   bidouble = new BiCGDouble();
  fId_rho_2 = DM->SubmitObject(bidouble);
  bidouble++;
  //   bidouble = new BiCGDouble();
  fId_alpha = DM->SubmitObject(bidouble);
  bidouble++;
  //   bidouble = new BiCGDouble();
  fId_beta = DM->SubmitObject(bidouble);
  bidouble++;
  //   bidouble = new BiCGDouble();
  fId_omega = DM->SubmitObject(bidouble);
  bidouble++;
  TBiCGInt * biint = new TBiCGInt();
  fId_max_iter = DM->SubmitObject(biint);
  //   bidouble = new BiCGDouble();
  fId_tol = DM->SubmitObject(bidouble);
 
  /**
   * Create and submit the following objects on all processors
   * Before submitting all necessary versioning must be set, avoiding extra work
   * on trivial dataversions.
   */
  int i=0;
  int nproc = CM->NumProcessors();
  TParMatrix * parm;
  TParVector * parv;
  TPartitionRelation * partrel;
  for(i=0;i<nproc;i++){
    parm = new TParMatrix[2];
    f_lId_A[i] = DM->SubmitObject(parm);
	parm++;
    //    parm = new TParMatrix();
    f_lId_M[i] = DM->SubmitObject(parm);
    parv = new TParVector[10];
    f_lId_x[i] = DM->SubmitObject(parv);
parv++;
    //    parv = new TParVector();
    f_lId_b[i] = DM->SubmitObject(parv);
parv++;
    //    parv = new TParVector();
    f_lId_p[i] = DM->SubmitObject(parv);
parv++;
    //    parv = new TParVector();
    f_lId_shat[i] = DM->SubmitObject(parv);
parv++;
    //    parv = new TParVector();
    f_lId_s[i] = DM->SubmitObject(parv);
parv++;
    //    parv = new TParVector();
    f_lId_phat[i] =DM->SubmitObject(parv);
parv++;
    //    parv = new TParVector();
    f_lId_t[i] = DM->SubmitObject(parv);
parv++;
    //    parv = new TParVector();
    f_lId_v[i] = DM->SubmitObject(parv);
parv++;
    //    parv = new TParVector();
    f_lId_rtilde[i] = DM->SubmitObject(parv);
parv++;
    //    parv = new TParVector();
    f_lId_r[i] =DM->SubmitObject(parv);
    partrel = new TPartitionRelation();
    f_lId_CMatrix[i] = DM->SubmitObject(partrel);
  }
  fObjectsSubmitted=true;
  
}
void TBiCGStab::SetupTaskData(){
  int i=0;
	int nproc = CM->NumProcessors();
	
	OOPDataVersion normbver;
	normbver = fDataDepend.Dep(fId_normb).ObjPtr()->Version();
	normbver.IncrementLevel(nproc);
	
	//Sets version of norm objects.
	fDataDepend.Dep(fId_normb).ObjPtr()->SetVersion(normbver, Id());
	
	//Sets version of fId_b object.
	OOPDataVersion ver;
	ver.IncrementLevel(-1);	
	TDistNorm * normb;
	
	for(i=0;i<nproc;i++){
		normb = new TDistNorm(i);
		normb->AddDependentData(OOPMDataDepend(fId_normb, EWriteAccess, ver));
		normb->AddDependentData(OOPMDataDepend(f_lId_b[i], EReadAccess, OOPDataVersion()));
		normb->AddDependentData(OOPMDataDepend(f_lId_CMatrix[i], EReadAccess, OOPDataVersion()));
		normb->Submit();
	}
	
	//fId_normb->Version --> n.1
	normbver.DecreaseLevel();
	normbver.Increment();
  //Falta ainda submeter a tarefa que checa se a normb == 0
	
	/**
	 * Each processor will
		1 - Set the appropriate version for its written data
		2 - Trigger the necessary tasks for the computation itself
	
		PS:
			->Verify versions.
	 */
	TMultAdd * madd;
	OOPDataVersion rver = fDataDepend.Dep(f_lId_r[0]).ObjPtr()->Version();
  OOPDataVersion Aver = fDataDepend.Dep(f_lId_A[0]).ObjPtr()->Version();
  OOPDataVersion Xver = fDataDepend.Dep(f_lId_x[0]).ObjPtr()->Version();
  //	OOPDataVersion dumyversion;
	for(i=0;i<nproc;i++){
		madd = new TMultAdd(i);
		madd->AddDependentData(OOPMDataDepend(f_lId_r[i], EVersionAccess, rver));
		madd->AddDependentData(OOPMDataDepend(f_lId_rtilde[i], EWriteAccess, rver));
		madd->AddDependentData(OOPMDataDepend(f_lId_b[i], EReadAccess, OOPDataVersion()));
		madd->AddDependentData(OOPMDataDepend(f_lId_A[i], EWriteAccess, Aver));
		madd->AddDependentData(OOPMDataDepend(f_lId_x[i], EWriteAccess, Xver));
		madd->AddDependentData(OOPMDataDepend(f_lId_CMatrix[i], EReadAccess, OOPDataVersion()));
		madd->Submit();
	}
	//f_lId_x->Version --> n.1
  //f_lId_A.Version --> n.1
  //f_lId_rtilde.Version --> n.1
  rver.Increment();
	Aver.Increment();
  Xver.Increment();
	/**
	 * resid = Norm(r)/normb
   * The first task implements the conditinal on the if
   * The task is diveded in two subtasks: Compute the Distributed norm on r; and the evaluation for the
   * conditional and the subsequent update on the residue.
	 */

   /**
    * Compute the distributed norm of r
    */
  OOPDataVersion normrver;
	normrver = fDataDepend.Dep(fId_normr).ObjPtr()->Version();
	normrver.IncrementLevel(nproc);
	fDataDepend.Dep(fId_normr).ObjPtr()->SetVersion(normrver, Id());
	
	TDistNorm * normr;
	for(i=0;i<nproc;i++){
		normr = new TDistNorm(i);
		ver.SetLevelVersion(1,-1);
		normr->AddDependentData(OOPMDataDepend(fId_normr, EWriteAccess, ver));
		normr->AddDependentData(OOPMDataDepend(f_lId_r[i], EReadAccess, rver));
		normr->AddDependentData(OOPMDataDepend(f_lId_CMatrix[i], EReadAccess, OOPDataVersion()));
		normr->Submit();
	}
	//fId_normr->Version --> n.1
	normrver.DecreaseLevel();
	normrver.Increment();
	
	/**
	 * if(resid = normr/normb){
      tol=resid;
      max_iter=0;
      return 0;
   * }
   * If true is returned the necessary values are updated and the all versions from all variables are
   * decreased one level and have this level incremented.
   * Having that version configuration the BiCGStab terminates.
	 */
     TBiCG_One * bicg_one = new TBiCG_One(0);
	OOPDataVersion resid_ver = fDataDepend.Dep(fId_resid).ObjPtr()->Version();
	OOPDataVersion tol_ver = fDataDepend.Dep(fId_tol).ObjPtr()->Version();
	OOPDataVersion max_iter_ver = fDataDepend.Dep(fId_max_iter).ObjPtr()->Version();
    
	bicg_one->AddDependentData(OOPMDataDepend(fId_resid,EWriteAccess,resid_ver));
	bicg_one->AddDependentData(OOPMDataDepend(fId_normb,EReadAccess,normbver));
	bicg_one->AddDependentData(OOPMDataDepend(fId_normr,EReadAccess,normrver));
  bicg_one->AddDependentData(OOPMDataDepend(fId_tol,EWriteAccess,tol_ver));
  bicg_one->AddDependentData(OOPMDataDepend(fId_max_iter,EWriteAccess,max_iter_ver));
	bicg_one->Submit();

  /**
   * Loop execution will be started according to normb version.
   * The loop task is responsible for set all necessary versions on the before
   * submiting remaining tasks.
   */
  CreateLoop(normbver);
  
	
	
	/**
	 * Loop
		A
		M
		x
		b

		p
		phat
		s
		shat
		t
		v
		CMatrix

		rtilde
		r
	*/



	/**
	max_iter
	rho_1
	r
	rtilde
	normb
	p
	rho_2
	alpha
	omega
	beta
	v
	phat
	s
	x
	shat
	t
	resid
	 * Repetion for loop
	 */
	
	/**
	 * Add dependency to the following objects
	fId_rho_1
	fId_rho_2
	fId_alpha
	fId_beta
	fId_omega
	fId_max_iter
	fId_tol
	*/
}
/** This function declares and submits the loop found on the BiCGStab code.
@since 09-01-2004
@author Gustavo C. Longhin
 */
void TBiCGStab::CreateLoop(OOPDataVersion & normbVersion){
	TLoopFor * loopfor = new TLoopFor(0);

	OOPDataVersion auxver;

	auxver = fDataDepend.Dep(fId_max_iter).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_max_iter,EVersionAccess,auxver));

	auxver = fDataDepend.Dep(fId_rho_1).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_rho_1,EVersionAccess,auxver));


	auxver = fDataDepend.Dep(fId_rho_2).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_rho_2,EVersionAccess,auxver));

  auxver = fDataDepend.Dep(fId_alpha).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_alpha,EVersionAccess,auxver));

	auxver = fDataDepend.Dep(fId_omega).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_omega,EVersionAccess,auxver));

	auxver = fDataDepend.Dep(fId_beta).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_beta,EVersionAccess,auxver));

	//auxver = fId_normb.Version();
  /**
   * Synchronizes the loop execution with normbVersion parameter.
   */
	loopfor->AddDependentData(OOPMDataDepend(fId_normb,EVersionAccess,normbVersion));

	auxver = fDataDepend.Dep(fId_tol).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_tol,EVersionAccess,auxver));

  auxver = fDataDepend.Dep(fId_normr).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_normr,EVersionAccess,auxver));

	auxver = fDataDepend.Dep(fId_resid).ObjPtr()->Version();
	loopfor->AddDependentData(OOPMDataDepend(fId_resid,EVersionAccess,auxver));

				  int i;
				  int nproc;
	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_p[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_p[i],EVersionAccess,auxver));
	}

  for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_A[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_A[i],EVersionAccess,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_M[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_M[i],EVersionAccess,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_v[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_v[i],EVersionAccess,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_phat[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_phat[i],EVersionAccess,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_s[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_s[i],EVersionAccess,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_x[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_x[i],EVersionAccess,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_shat[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_shat[i],EVersionAccess,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_t[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_t[i],EVersionAccess,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_rtilde[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_rtilde[i],EVersionAccess,auxver));
	}

	for(i=0;i<nproc;i++){
		auxver = fDataDepend.Dep(f_lId_r[i]).ObjPtr()->Version();
		loopfor->AddDependentData(OOPMDataDepend(f_lId_r[i],EVersionAccess,auxver));
	}
  loopfor->Submit();
}
