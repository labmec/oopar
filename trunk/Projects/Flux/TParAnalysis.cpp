/* Generated by Together */
#include "TParAnalysis.h"
#include <iostream>
#include "TParVector.h" 
#include "ooptaskmanager.h"
#include "oopterminationtask.h"

class OOPStorageBuffer;

void TParAnalysis::Print (ostream & out)
{
	out << "Print ParAnalysis" << endl;
}
void TParAnalysis::SetupEnvironment ()
{
	TPartitionRelation *table =
		TPartitionRelation::CreateRandom (fNumPartitions);
	// int ProcId = DM->GetProcID();
	// message #1.2 to table:TPartitionRelation
	// TPartitionRelation * table = ;
	int npartitions = table->GetNPartitions ();
	int ip;
	// message #1.3 to rhs:TParVector
	vector< TParVector * > RhsVec (npartitions);
	fRhsId.resize (npartitions);
	for (ip = 0; ip < npartitions; ip++)
		RhsVec[ip] = new TParVector ();
	// message #1.4 to state:TParVector
	vector < TParVector * > StateVec (npartitions);
	fStateId.resize (npartitions);
	for (ip = 0; ip < npartitions; ip++)
		StateVec[ip] = new TParVector ();
	// message #1.5 to mesh:TParMesh
	vector < TParMesh * >MeshVec (npartitions);
	fMeshId.resize (npartitions);
	for (ip = 0; ip < npartitions; ip++)
		MeshVec[ip] = new TParMesh ();
	int i;
	// message #1.7 to ver:OOPDataVersion
	for (i = 0; i < npartitions; i++) {
		// message #1.8.1 to DM:OOPDataManager
		fRhsId[i] = TM()->DM()->SubmitObject (RhsVec[i]);
		// message #1.8.3 to DM:OOPDataManager
		fStateId[i] = TM()->DM()->SubmitObject (StateVec[i]);
		// message #1.8.5 to DM:OOPDataManager
		fMeshId[i] = TM()->DM()->SubmitObject (MeshVec[i]);
		table->SetMeshId (i, fMeshId[i]);
	}
	// message #1.6 to ver:OOPDataVersion
	OOPDataVersion ver;
	int level = 0;
	int version = 0;
	ver.SetLevelVersion (level, version);
	OOPMDataState st = EReadAccess;
	fRelationTable = TM()->DM()->SubmitObject (table);
	GetDependencyList().Clear(TM()->DM());
	int processor = GetProcID();
	char * msg = "TParAnalysis dependency on all data relationtable version ";
	PrintLog(TaskLog, msg);
	ver.ShortPrint (TaskLog);
	TaskLog << endl;
	AddDependentData (OOPAccessTag (fRelationTable, st, ver, processor));
	st = EVersionAccess;
	for (ip = 0; ip < npartitions; ip++) {
		AddDependentData (OOPAccessTag (fMeshId[ip], st, ver, processor));
	}
	for (ip = 0; ip < npartitions; ip++) {
		AddDependentData (OOPAccessTag (fStateId[ip], st, ver, processor));
	}
	for (ip = 0; ip < npartitions; ip++) {
		AddDependentData (OOPAccessTag (fRhsId[ip], st, ver, processor));
	}
	/* 
	 * OOPObjectId tempid; tempid.SetId(200);
	 * AddDependentData(OOPMDataDepend(tempid,st,ver)); */
	// MetaData dependence still needs to be submitted to the DM
	// which is performed as follows.
	// SubmitDependentData();
}
void TParAnalysis::CreateParCompute ()
{
	int ndepend = GetDependencyList().Count();
	if (ndepend != 3 * fNumPartitions + 1) {
		PrintLog(TaskLog, "TParAnalysis I dont understand\n");
		cout << "TParAnalysis I dont understand\n";
	}
	OOPObjectId tableid = GetTag(0).Id();
	OOPDataVersion randver;
	randver.SetLevelVersion (0, 10);
	randver.IncrementLevel (13);
	randver.SetLevelVersion (1, 5);
	randver.IncrementLevel (25);
	randver.SetLevelVersion (2, 24);
	OOPDataVersion taskver (randver);
	taskver.SetLevelVersion (1, -1);
	fTaskVersion = taskver;
	
	// skipping the mesh dependency
	int count = 0;
	// Setting the data version
	// fTaskVersionAccess não estava sendo setado.
	PrintLog(TaskLog, "TParAnalysis setting the version of rhs and state to ");
	randver.ShortPrint(TaskLog);
	TaskLog << endl;
#ifdef VERBOSE
	cout << "TParAnalysis setting the version of rhs and state to " <<
		endl;

	randver.ShortPrint (cout);
#endif
	/*while (count < fNumPartitions) {
		int index=count*3+2;
		fDataDepend.Dep (index).ObjPtr()->SetVersion (randver, Id ());
		fDataDepend.Dep (index+1).ObjPtr()->SetVersion (randver, Id ());
		count++;
	}*/
	
	while (count < 2 * fNumPartitions) {
		GetTag(count + fNumPartitions + 1).SetVersion(randver);
		count++;
	}
	// message #1.1 to pc:TParCompute
	TParCompute *pc = new TParCompute (fNumProcessors-1-GetProcID(), fNumPartitions);
	//TParCompute *pc = new TParCompute (GetProcID(), fNumPartitions);
	OOPDataVersion ver;
	pc->AddDependentData(OOPAccessTag(tableid,EReadAccess,ver,GetProcID()));
	pc->SetMeshId (fMeshId, ver);
	pc->SetRhsId (fRhsId, taskver);
	pc->SetStateId (fStateId, taskver);
	pc->SetPartitionRelationId (tableid, ver);
	// OOPMDataState st = EReadAccess;
	// pc->AddDependentData(tableid,st,ver);
	// pc->SetPartitionRelationId(tableId , ver);
	// message #1.9 to pc:TParCompute
	TM()->Submit(pc);
	GetDependencyList().Clear(TM()->DM());
	count = 0;
	randver.Increment ();
	PrintLog(TaskLog, "TParAnalysis::CreateParCompute I depend on version for rhs and state");
	randver.ShortPrint(TaskLog);
	TaskLog << endl;
#ifdef VERBOSE
	cout << "TParAnalysis::CreateParCompute I depend on version for rhs and state" << endl;
	randver.ShortPrint (cout);
#endif
//  while(count < fNumPartitions) {
	// Na primeira passada por aqui, ObjPtr de *dep está nulo !!!!
//    AddDependentData(OOPMDataDepend(fStateId[count],st,randver));
//    count++;
//  }
	count = 0;
	while (count < fNumPartitions) {
		// Na primeira passada por aqui, ObjPtr de *dep está nulo
		// !!!!
		AddDependentData (OOPAccessTag(fRhsId[count], EVersionAccess, randver, GetProcID()));
		count++;
	}
	// SubmitDependentData !!!
	// SubmitDependentData();
}
void TParAnalysis::SetAppropriateVersions ()
{
	OOPDataVersion ver;
	// OOPMDataState st = EReadAccess;
	int ndep = GetDependencyList().Count();
	int id = 0;
	while (id < ndep) {
		OOPDataVersion solver = GetTag(id).Version ();
		AdaptSolutionVersion (solver);
		PrintLog(TaskLog,"TParAnalysis::SetAppropriateVersion new version is ");
		solver.ShortPrint (TaskLog);
		TaskLog << endl;
#ifdef VERBOSE
		cout << "TParAnalysis::SetAppropriateVersion new version is ";
		solver.ShortPrint (cout);
#endif
		GetTag(id).SetVersion(solver);
		ver = solver;
		id++;
	}
	ver.Increment ();
	GetDependencyList().Clear(TM()->DM());
	if (ver.GetNLevels () < 2) {
		this->SetRecurrence (false);
#ifdef VERBOSE
		cout << "TParAnalysis esta saindo\n";
		ver.ShortPrint(cout);
		cout.flush();
#endif
		//OOPTerminationTask * termtask = new OOPTerminationTask(fProc);
		int i;
		for(i=0;i<fNumPartitions;i++){
			OOPTerminationTask * termtask = new OOPTerminationTask(i);
			TM()->Submit(termtask);
		}
	}
	else {
		int count = 0;
		while (count < fNumPartitions) {
			// Na primeira passada por aqui, ObjPtr de *dep está
			// nulo !!!!
			AddDependentData (OOPAccessTag(fRhsId[count], EVersionAccess,ver,GetProcID()));
			count++;
		}
	}
}
void TParAnalysis::AdaptSolutionVersion (OOPDataVersion & version)
{
	int depth = fTaskVersion.GetNLevels ();
	int versdepth = version.GetNLevels ();
//  cout << "TParAnalysis::AdaptSolutionVersion before "; version.Print(cout);
	int d;
	for (d = versdepth; d < depth; d++) {
		int taskver = fTaskVersion.GetLevelVersion (d);
		if (taskver != -1) {
			version.IncrementLevel (taskver + 1);
			version.SetLevelVersion (d, taskver);
		}
		else {
			version.IncrementLevel (1);
			version.SetLevelVersion (d, 1);
		}
	}
//  cout << "TParAnalysis::AdaptSolutionVersion after "; version.Print(cout);
}
OOPMReturnType TParAnalysis::Execute ()
{
	if (fRelationTable.IsZeroOOP ()) {
		SetupEnvironment ();
	}
	else if (fTaskVersion.GetNLevels () <= 1) {
		CreateParCompute ();
	}
	else {
		SetAppropriateVersions ();
	}
	return ESuccess;
}
TParAnalysis::TParAnalysis ():OOPTask ()
{
	fNumPartitions = 0;
	fNumProcessors = -1;
}

TParAnalysis::TParAnalysis (int Procid):OOPTask (Procid)
{
	fNumPartitions = 0;
	fNumProcessors = -1;
}
TParAnalysis::TParAnalysis (int Procid, int numpartitions, int numproc):OOPTask (Procid) {
	fNumPartitions = numpartitions;
	fNumProcessors = numproc;
	SetRecurrence ();
}
  /**
   * Packs the object in on the buffer so it can be transmitted through the network.
   * The Pack function  packs the object's class_id while function Unpack() doesn't,
   * allowing the user to identify the next object to be unpacked.
   * @param *buff A pointer to TSendStorage class to be packed.
   */
void TParAnalysis::Write (TPZStream & buf, int withclassid)
{
	OOPTask::Write(buf,withclassid);
	buf.Write (&fNumPartitions);
	buf.Write (&fNumProcessors);
	fRelationTable.Write (buf);
	fTaskVersion.Write (buf);
	int ip, np = fRhsId.size ();
	buf.Write (&np);
	for (ip = 0; ip < np; ip++) {
		fRhsId[ip].Write (buf);
		fMeshId[ip].Write (buf);
		fStateId[ip].Write (buf);
	}
}
  /**
   * Unpacks the object class_id
   * @param *buff A pointer to TSendStorage class to be unpacked.
   */
void TParAnalysis::Read (TPZStream & buf, void * context)
{
	OOPTask::Read(buf,context);
	buf.Read (&fNumPartitions);
	buf.Read (&fNumProcessors);
	fRelationTable.Read (buf);
	fTaskVersion.Read (buf);
	int ip, np;
	buf.Read (&np);
	fRhsId.resize (np);
	fMeshId.resize (np);
	fStateId.resize (np);
	for (ip = 0; ip < np; ip++) {
		fRhsId[ip].Read (buf);
		fMeshId[ip].Read (buf);
		fStateId[ip].Read (buf);
	}

}
TPZSaveable *TParAnalysis::Restore (TPZStream & buf, void * context)
{
	TParAnalysis *par = new TParAnalysis;// (0);
	par->Read (buf);
	return par;
}

template class TPZRestoreClass<TParAnalysis, TPARANAYSIS_ID>;

