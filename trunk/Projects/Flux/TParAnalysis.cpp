/* Generated by Together */

#include "TParAnalysis.h"

void TParAnalysis::SetupEnvironment(){
	
  TPartitionRelation *table = TPartitionRelation::CreateRandom(fNumPartitions);
  //  int ProcId = DM->GetProcID();
	
  // message #1.2 to table:TPartitionRelation
  // TPartitionRelation * table = ;

  int npartitions = table->GetNPartitions();


  int ip;
  // message #1.3 to rhs:TParRhs
  vector<TParRhs *> RhsVec(npartitions);
  vector<OOPObjectId> RhsId(npartitions);
  for(ip=0; ip<npartitions; ip++) RhsVec[ip] = new TParRhs();

  // message #1.4 to state:TParState
  vector<TParState *> StateVec(npartitions);
  vector<OOPObjectId> StateId(npartitions);
  for(ip=0; ip<npartitions; ip++) StateVec[ip] = new TParState();

  // message #1.5 to mesh:TParMesh
  vector<TParMesh *> MeshVec(npartitions);
  vector<OOPObjectId> MeshId(npartitions);
  for(ip=0; ip<npartitions; ip++) MeshVec[ip] = new TParMesh();

  int i;
  // message #1.7 to ver:OOPDataVersion
  for (i = 0; i < npartitions; i++) {
    // message #1.8.1 to DM:OOPDataManager
    RhsId[i] = DM->SubmitObject(RhsVec[i], 1);

    // message #1.8.3 to DM:OOPDataManager
    StateId[i] = DM->SubmitObject(StateVec[i], 1);

    // message #1.8.5 to DM:OOPDataManager
    MeshId[i] = DM->SubmitObject(MeshVec[i], 1);
    table->SetMeshId(i,MeshId[i]);
  }
  // message #1.6 to ver:OOPDataVersion
  OOPDataVersion ver;
  int level = 0;
  int version = 0;
  ver.SetLevelVersion(level, version);
  OOPMDataState st = EReadAccess;
  fRelationTable = DM->SubmitObject(table, 1);

  ReleaseAccessRequests();

  AddDependentData(fRelationTable,st,ver);

  st = EVersionAccess;
  for(ip=0; ip<npartitions; ip++) {
    AddDependentData(MeshId[ip],st,ver);
  }

  for(ip=0; ip<npartitions; ip++) {
    AddDependentData(StateId[ip],st,ver);
  }

  for(ip=0; ip<npartitions; ip++) {
    AddDependentData(RhsId[ip],st,ver);
  }

}

void TParAnalysis::CreateParCompute() {

  //  int ndepend = GetNDependentData();
  deque<OOPMDataDepend>::iterator dep;
  dep = fDataDepend.begin();
  OOPObjectId tableid = (*dep).fDataId;
  dep++;

  OOPDataVersion randver;
  randver.SetLevelVersion(0,10);
  randver.IncrementLevel(13);
  randver.SetLevelVersion(1,12);
  randver.IncrementLevel(25);
  randver.SetLevelVersion(2,24);
  OOPDataVersion taskver(randver);
  taskver.SetLevelVersion(1,-1);
  fTaskVersion = taskver;
  // skipping the mesh dependency
  int count =0;
  while(count < fNumPartitions) {
    dep ++;
    count++;
  }
  count = 0;
  // Setting the data version
  while(count < 2*fNumPartitions) {
    (*dep).ObjPtr()->SetVersion(randver,Id());
    dep ++;
    count++;
  }


  // message #1.1 to pc:TParCompute
  TParCompute * pc = new TParCompute(GetProcID(),fNumPartitions);

  OOPDataVersion ver;
  OOPMDataState st = EReadAccess;
  pc->AddDependentData(tableid,st,ver);
  // set mesh dependency
  count = 0;
  dep = fDataDepend.begin();
  while(count < fNumPartitions) {
    pc->AddDependentData((*dep).ObjPtr()->Id(),st,(*dep).ObjPtr()->Version());
  }
  // set the dependency on the state and rhs objects
  count =0;
  while(count < 2*fNumPartitions) {
    pc->AddDependentData((*dep).ObjPtr()->Id(),st,taskver);
  }


  //	pc->SetPartitionRelationId(tableId , ver);
  // message #1.9 to pc:TParCompute
  pc->Submit();
  ReleaseAccessRequests();

  dep = fDataDepend.begin();
  dep++;
  count =0;
  while(count < fNumPartitions) {
    dep ++;
    count++;
  }
  count = 0;
  // Setting the data version
  while(count < 2*fNumPartitions) {
    OOPDataVersion ver((*dep).ObjPtr()->Version());
    ver.Increment();
    AddDependentData((*dep).ObjPtr()->Id(),st,ver);
    dep ++;
    count++;
  }
}

