/* Generated by Together */

#include "TPartitionRelation.h"
#include "pzvec.h"

TPartitionRelation::TPartitionRelation() : OOPSaveable() {}
vector<int> TPartitionRelation::OutgoingContribution(int partition){
	vector<int> out;
	int i;
	for(i=0;i<fNumPartitions;i++){
		//Ainda precisa ser implementado com a funcionalidade esperada
		if (fRelation[partition][i].NContributions()){
			out.push_back(i);
		}
	}
	return out;
	
	
}
int TPartitionRelation::IncomingContribution(int partition){
	int i;
	int count = 0;
	for(i=0;i<fNumPartitions;i++){
		//Ainda precisa ser implementado com a funcionalidade esperada
		if (fRelation[i][partition].NContributions()){
			count ++;
		}
	}
	return count;
	
}
int TPartitionRelation::GetNPartitions(){
	return fNumPartitions;
}
long TPartitionRelation::GetClassID(){
	return fClassId;
}

TPartitionRelation * TPartitionRelation::CreateRandom(int npart){
	TPartitionRelation * part = new TPartitionRelation(npart);
	part->fRelation.Resize(npart);
	int i,j;
	for(i=0;i<npart;i++)
		part->fRelation[i].Resize(npart);
	
	for(i=0;i<npart;i++){
		for(j=0;j<npart;j++){
			part->fRelation[i][j].InitializeRandom(30);
		}
	}
	
	return part;
}
